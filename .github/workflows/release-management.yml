name: Release Management Pipeline

on:
  push:
    tags:
      - 'v*'
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., v1.0.0)'
        required: true
        type: string
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging

env:
  PYTHON_VERSION: '3.13'
  REGISTRY: docker.io
  IMAGE_NAME: kastoma/api

jobs:
  validate-release:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      is_prerelease: ${{ steps.version.outputs.is_prerelease }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Extract version information
      id: version
      run: |
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          VERSION="${{ github.event.inputs.version }}"
        elif [[ "${{ github.ref_type }}" == "tag" ]]; then
          VERSION="${{ github.ref_name }}"
        else
          VERSION=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
        fi
        
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        
        if [[ "$VERSION" =~ -[a-zA-Z] ]]; then
          echo "is_prerelease=true" >> $GITHUB_OUTPUT
        else
          echo "is_prerelease=false" >> $GITHUB_OUTPUT
        fi
        
        echo "Detected version: $VERSION"
        echo "Is prerelease: $(echo $VERSION | grep -q '\-[a-zA-Z]' && echo true || echo false)"

    - name: Validate version format
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        if [[ ! "$VERSION" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9]+)?$ ]]; then
          echo "Invalid version format: $VERSION"
          echo "Expected format: v1.2.3 or v1.2.3-alpha"
          exit 1
        fi
        echo "Valid version format: $VERSION"

  build-release:
    runs-on: ubuntu-latest
    needs: validate-release
    permissions:
      contents: read
      packages: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    - name: Extract metadata for release
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=semver,pattern={{version}},value=${{ needs.validate-release.outputs.version }}
          type=semver,pattern={{major}}.{{minor}},value=${{ needs.validate-release.outputs.version }}
          type=semver,pattern={{major}},value=${{ needs.validate-release.outputs.version }}
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push release Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          BUILDKIT_INLINE_CACHE=1
          VERSION=${{ needs.validate-release.outputs.version }}

    - name: Run comprehensive security scan on release image
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.validate-release.outputs.version }}
        format: 'sarif'
        output: 'trivy-release-results.sarif'

    - name: Upload release security scan results
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: 'trivy-release-results.sarif'
      continue-on-error: true

  deploy-staging:
    runs-on: ubuntu-latest
    needs: [validate-release, build-release]
    if: needs.validate-release.outputs.is_prerelease == 'true' || github.event.inputs.environment == 'staging'
    environment: staging
    
    steps:
    - name: Deploy to staging
      run: |
        echo "Deploying ${{ needs.validate-release.outputs.version }} to staging environment..."
        # Add your staging deployment logic here
        # docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.validate-release.outputs.version }}
        # docker-compose -f docker-compose.staging.yml up -d
        # Run smoke tests
        # kubectl set image deployment/kastoma-api kastoma-api=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.validate-release.outputs.version }}

    - name: Run staging smoke tests
      run: |
        echo "Running smoke tests on staging..."
        # curl -f https://staging.kastoma.com/health || exit 1
        # Add more comprehensive health checks

  deploy-production:
    runs-on: ubuntu-latest
    needs: [validate-release, build-release, deploy-staging]
    if: needs.validate-release.outputs.is_prerelease == 'false' && (github.event_name == 'release' || github.event.inputs.environment == 'production')
    environment: production
    
    steps:
    - name: Pre-deployment checks
      run: |
        echo "Running pre-deployment checks..."
        # Check database migration status
        # Verify all required secrets are available
        # Check system resources
        
    - name: Deploy to production
      run: |
        echo "Deploying ${{ needs.validate-release.outputs.version }} to production environment..."
        # Add your production deployment logic here
        # Implement blue-green deployment
        # docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.validate-release.outputs.version }}
        # kubectl set image deployment/kastoma-api kastoma-api=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.validate-release.outputs.version }}
        # Wait for rollout to complete
        # kubectl rollout status deployment/kastoma-api

    - name: Run production health checks
      run: |
        echo "Running production health checks..."
        # curl -f https://api.kastoma.com/health || exit 1
        # Run comprehensive health checks
        # Monitor key metrics

    - name: Rollback on failure
      if: failure()
      run: |
        echo "Deployment failed, initiating rollback..."
        # kubectl rollout undo deployment/kastoma-api
        # Notify team of rollback

  create-github-release:
    runs-on: ubuntu-latest
    needs: [validate-release, build-release]
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')
    permissions:
      contents: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Generate changelog
      run: |
        echo "# Release ${{ needs.validate-release.outputs.version }}" > CHANGELOG.md
        echo "" >> CHANGELOG.md
        echo "## What's Changed" >> CHANGELOG.md
        
        # Get commits since last tag
        LAST_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
        if [[ -n "$LAST_TAG" ]]; then
          git log --pretty=format:"- %s (%h)" $LAST_TAG..HEAD >> CHANGELOG.md
        else
          git log --pretty=format:"- %s (%h)" HEAD~10..HEAD >> CHANGELOG.md
        fi
        
        echo "" >> CHANGELOG.md
        echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/$LAST_TAG...${{ needs.validate-release.outputs.version }}" >> CHANGELOG.md

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ needs.validate-release.outputs.version }}
        name: Release ${{ needs.validate-release.outputs.version }}
        body_path: CHANGELOG.md
        prerelease: ${{ needs.validate-release.outputs.is_prerelease }}
        generate_release_notes: true
        files: |
          CHANGELOG.md

  notify-release:
    runs-on: ubuntu-latest
    needs: [validate-release, build-release, deploy-production, create-github-release]
    if: always()
    
    steps:
    - name: Notify on successful release
      if: needs.deploy-production.result == 'success'
      run: |
        echo "Release ${{ needs.validate-release.outputs.version }} deployed successfully!"
        # Add notification logic (Slack, email, etc.)
        # Post to company chat
        # Update status page

    - name: Notify on failed release
      if: needs.deploy-production.result == 'failure'
      run: |
        echo "Release ${{ needs.validate-release.outputs.version }} deployment failed!"
        # Add notification logic for failures
        # Alert on-call team
        # Create incident ticket